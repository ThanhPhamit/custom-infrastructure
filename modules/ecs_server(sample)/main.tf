resource "aws_iam_policy" "ecs_task_execution_policy" {
  name   = "${var.app_name}-ecs-task-execution-policy"
  path   = "/"
  policy = data.aws_iam_policy_document.ecs_task_execution_policy_document.json

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-ecs-task-policy"
    }
  )
}

module "ecs_task_execution_role" {
  source     = "../iam_role"
  name       = "${var.app_name}-ecs-task-execution-role"
  identifier = "ecs-tasks.amazonaws.com"

  policy_arns_map = {
    "policy_1" = aws_iam_policy.ecs_task_execution_policy.arn
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-ecs-task-execution-role"
    }
  )
}

resource "aws_iam_policy" "ecs_task_policy" {
  name   = "${var.app_name}-ecs-task-policy"
  path   = "/"
  policy = data.aws_iam_policy_document.ecs_task.json

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-ecs-task-policy"
    }
  )
}

module "ecs_task_role" {
  source     = "../iam_role"
  name       = "${var.app_name}-ecs-task-role"
  identifier = "ecs-tasks.amazonaws.com"
  policy_arns_map = {
    "policy_1" = aws_iam_policy.ecs_task_policy.arn
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-ecs-task-role"
    }
  )
}

# =============================================================================
# SECRETS - UUID suffix for unique naming
# =============================================================================
resource "random_uuid" "ecs_secrets_uuid" {}

# =============================================================================
# AUTO-GENERATED SECRETS (5 secrets)
# These secrets are automatically generated by Terraform
# =============================================================================

# Admin Secret Key
resource "random_password" "admin_secret_key" {
  length  = 64
  special = true
}

resource "aws_secretsmanager_secret" "admin_secret_key" {
  name = "${var.app_name}-ecs-admin-secret-key-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-admin-secret-key"
  })
}

resource "aws_secretsmanager_secret_version" "admin_secret_key" {
  secret_id     = aws_secretsmanager_secret.admin_secret_key.id
  secret_string = random_password.admin_secret_key.result
}

# Application Secret Key (auto-generated)
resource "random_password" "secret_key" {
  length  = 32
  special = true
}

resource "aws_secretsmanager_secret" "secret_key" {
  name = "${var.app_name}-ecs-secret-key-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-secret-key"
  })
}

resource "aws_secretsmanager_secret_version" "secret_key" {
  secret_id     = aws_secretsmanager_secret.secret_key.id
  secret_string = random_password.secret_key.result
}

# JWT Secret Key
resource "random_password" "jwt_secret_key" {
  length  = 64
  special = true
}

resource "aws_secretsmanager_secret" "jwt_secret_key" {
  name = "${var.app_name}-ecs-jwt-secret-key-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-jwt-secret-key"
  })
}

resource "aws_secretsmanager_secret_version" "jwt_secret_key" {
  secret_id     = aws_secretsmanager_secret.jwt_secret_key.id
  secret_string = random_password.jwt_secret_key.result
}

# JWT Refresh Secret Key
resource "random_password" "jwt_refresh_secret_key" {
  length  = 64
  special = true
}

resource "aws_secretsmanager_secret" "jwt_refresh_secret_key" {
  name = "${var.app_name}-ecs-jwt-refresh-secret-key-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-jwt-refresh-secret-key"
  })
}

resource "aws_secretsmanager_secret_version" "jwt_refresh_secret_key" {
  secret_id     = aws_secretsmanager_secret.jwt_refresh_secret_key.id
  secret_string = random_password.jwt_refresh_secret_key.result
}

# Crypto Secret Key (Base64 encoded, 32 bytes for AES-256)
resource "random_bytes" "crypto_secret_key" {
  length = 32
}

resource "aws_secretsmanager_secret" "crypto_secret_key" {
  name = "${var.app_name}-ecs-crypto-secret-key-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-crypto-secret-key"
  })
}

resource "aws_secretsmanager_secret_version" "crypto_secret_key" {
  secret_id     = aws_secretsmanager_secret.crypto_secret_key.id
  secret_string = random_bytes.crypto_secret_key.base64
}

# =============================================================================
# EXTERNAL SECRETS (6 secrets - passed from variables)
# These secrets are passed from outside and stored in Secrets Manager
# =============================================================================

# GMO Site Pass
resource "aws_secretsmanager_secret" "gmo_site_pass" {
  name = "${var.app_name}-ecs-gmo-site-pass-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-gmo-site-pass"
  })
}

resource "aws_secretsmanager_secret_version" "gmo_site_pass" {
  secret_id     = aws_secretsmanager_secret.gmo_site_pass.id
  secret_string = var.gmo_site_pass
}

# GMO Shop Pass
resource "aws_secretsmanager_secret" "gmo_shop_pass" {
  name = "${var.app_name}-ecs-gmo-shop-pass-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-gmo-shop-pass"
  })
}

resource "aws_secretsmanager_secret_version" "gmo_shop_pass" {
  secret_id     = aws_secretsmanager_secret.gmo_shop_pass.id
  secret_string = var.gmo_shop_pass
}

# Twilio Auth Token
resource "aws_secretsmanager_secret" "twilio_auth_token" {
  name = "${var.app_name}-ecs-twilio-auth-token-${substr(random_uuid.ecs_secrets_uuid.result, 0, 4)}"

  tags = merge(var.tags, {
    Name = "${var.app_name}-ecs-twilio-auth-token"
  })
}

resource "aws_secretsmanager_secret_version" "twilio_auth_token" {
  secret_id     = aws_secretsmanager_secret.twilio_auth_token.id
  secret_string = var.twilio_auth_token
}

# =============================================================================
# ECS TASK DEFINITION
# =============================================================================

resource "aws_ecs_task_definition" "task_definition" {
  family = "${var.app_name}-server"

  cpu                      = var.task_cpu_size
  memory                   = var.task_memory_size
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]

  container_definitions = templatefile("${path.module}/container_definitions/server-task-def.json.tpl", {
    container_name    = var.container_names[0]
    container_port    = var.container_port
    repository_url    = var.repository_url
    memory_size       = var.task_memory_size
    app_name          = var.app_name
    aws_region        = var.region
    health_check_path = var.app_health_check_path

    # Environment variables
    environment          = var.environment
    allowed_hosts        = var.allowed_hosts
    error_code_prefix    = var.error_code_prefix
    time_zone            = var.time_zone
    cors_allowed_origins = var.cors_allowed_origins
    client_server        = var.client_server

    # Database
    postgres_host   = var.postgres_host
    postgres_port   = tostring(var.postgres_port)
    postgres_db     = var.postgres_db
    postgres_user   = var.postgres_user
    postgres_schema = var.postgres_schema

    # Cache
    cache_host = var.cache_host
    cache_port = tostring(var.cache_port)

    # JWT
    jwt_algorithms      = var.jwt_algorithms
    jwt_expires         = var.jwt_expires
    jwt_refresh_expires = var.jwt_refresh_expires

    # GMO Payment
    gmo_prefix_member = var.gmo_prefix_member
    gmo_site_id       = var.gmo_site_id
    gmo_shop_id       = var.gmo_shop_id
    dev_gmo_base_url  = var.dev_gmo_base_url
    prod_gmo_base_url = var.prod_gmo_base_url

    # Email/SMTP
    email_host         = var.email_host
    email_port         = var.email_port
    email_use_tls      = tostring(var.email_use_tls)
    default_from_email = var.default_from_email

    # Twilio
    twilio_account_sid           = var.twilio_account_sid
    twilio_service_messaging_sid = var.twilio_service_messaging_sid
    phone_code                   = var.phone_code

    # Tax & Invoice
    tax                = tostring(var.tax)
    invoice_tax        = tostring(var.invoice_tax)
    order_prefix       = var.order_prefix
    consulting_prefix  = var.consulting_prefix
    invoice_prefix     = var.invoice_prefix
    invoice_range_days = tostring(var.invoice_range_days)

    # AWS
    aws_bucket               = var.aws_bucket
    aws_bucket_region        = var.aws_bucket_region
    aws_prefix_file_name     = var.aws_prefix_file_name
    aws_chime_default_region = var.aws_chime_default_region

    # Other
    debug                  = tostring(var.debug)
    http_x_forwarded_proto = var.http_x_forwarded_proto

    # Inquiry Emails
    inquiry_payment_email               = var.inquiry_payment_email
    inquiry_online_clinic_service_email = var.inquiry_online_clinic_service_email
    inquiry_other_email                 = var.inquiry_other_email
    inquiry_email_cc_to                 = var.inquiry_email_cc_to

    # ==========================================================================
    # Secrets ARNs (passed to task definition)
    # ==========================================================================

    # Auto-generated secrets (5 secrets)
    admin_secret_key_secret_arn       = aws_secretsmanager_secret.admin_secret_key.arn
    jwt_secret_key_secret_arn         = aws_secretsmanager_secret.jwt_secret_key.arn
    jwt_refresh_secret_key_secret_arn = aws_secretsmanager_secret.jwt_refresh_secret_key.arn
    crypto_secret_key_secret_arn      = aws_secretsmanager_secret.crypto_secret_key.arn
    secret_key_secret_arn             = aws_secretsmanager_secret.secret_key.arn

    # External secrets (7 secrets - passed from variables, stored in Secrets Manager)
    postgres_password_secret_arn   = var.postgres_password_secret_arn
    gmo_site_pass_secret_arn       = aws_secretsmanager_secret.gmo_site_pass.arn
    gmo_shop_pass_secret_arn       = aws_secretsmanager_secret.gmo_shop_pass.arn
    email_host_user_secret_arn     = var.email_host_user_secret_arn
    email_host_password_secret_arn = var.email_host_password_secret_arn
    twilio_auth_token_secret_arn   = aws_secretsmanager_secret.twilio_auth_token.arn
  })
  execution_role_arn = module.ecs_task_execution_role.iam_role_arn
  task_role_arn      = module.ecs_task_role.iam_role_arn

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-server-task-definition"
    }
  )
}

resource "aws_cloudwatch_log_group" "log" {
  count = length(var.container_names)
  name  = "/ecs_server/${var.app_name}/${var.container_names[count.index]}"
  tags = merge(
    var.tags,
    {
      Name = "/ecs_server/${var.app_name}/${var.container_names[count.index]}"
    }
  )
}

resource "random_uuid" "target_group_uuid" {}

resource "aws_lb_target_group" "target_group_blue" {
  name   = "${substr(var.app_name, 0, 18)}-server-blue-${substr(random_uuid.target_group_uuid.result, 0, 2)}"
  vpc_id = data.aws_vpc.selected.id

  port        = var.container_port
  protocol    = var.load_balancer_type == "nlb" ? "TCP" : "HTTP"
  target_type = "ip"

  health_check {
    port                = var.container_port
    timeout             = var.load_balancer_type == "nlb" ? 6 : 10
    protocol            = "HTTP"
    path                = var.app_health_check_path
    matcher             = "200-299"
    healthy_threshold   = 2
    unhealthy_threshold = 3
    interval            = 30
  }

  lifecycle {
    create_before_destroy = true
  }
  tags = merge(
    var.tags,
    {
      Name = "${substr(var.app_name, 0, 18)}-server-blue-${substr(random_uuid.target_group_uuid.result, 0, 2)}"
    }
  )
}

resource "aws_lb_target_group" "target_group_green" {
  name   = "${substr(var.app_name, 0, 18)}-server-green-${substr(random_uuid.target_group_uuid.result, 0, 2)}"
  vpc_id = data.aws_vpc.selected.id

  port        = var.container_port
  protocol    = var.load_balancer_type == "nlb" ? "TCP" : "HTTP"
  target_type = "ip"

  health_check {
    port                = var.container_port
    timeout             = var.load_balancer_type == "nlb" ? 6 : 10
    protocol            = "HTTP"
    path                = var.app_health_check_path
    matcher             = "200-299"
    healthy_threshold   = 2
    unhealthy_threshold = 3
    interval            = 30
  }

  lifecycle {
    create_before_destroy = true
  }

  tags = merge(
    var.tags,
    {
      Name = "${substr(var.app_name, 0, 18)}-server-green-${substr(random_uuid.target_group_uuid.result, 0, 2)}"
    }
  )
}

# ALB listener rules (path-based routing)
resource "aws_lb_listener_rule" "http_rule" {
  count        = var.load_balancer_type == "alb" ? 1 : 0
  listener_arn = var.http_prod_listener_arn

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.target_group_blue.id
  }
  condition {
    path_pattern {
      values = ["*"]
    }
  }
  lifecycle {
    ignore_changes = [
      action,
    ]
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-server-http-rule"
    }
  )
}

resource "aws_lb_listener_rule" "http_test_rule" {
  count        = var.load_balancer_type == "alb" ? 1 : 0
  listener_arn = var.http_test_listener_arn

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.target_group_green.id
  }
  condition {
    path_pattern {
      values = ["*"]
    }
  }
  lifecycle {
    ignore_changes = [
      action,
    ]
  }
  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-server-http-test-rule"
    }
  )
}

# For NLB, we create the listeners directly since NLB module doesn't create them
# TCP listener for HTTP (port 80)
resource "aws_lb_listener" "nlb_http" {
  count             = var.load_balancer_type == "nlb" ? 1 : 0
  port              = "80"
  protocol          = "TCP"
  load_balancer_arn = var.nlb_arn

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.target_group_blue.arn
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-nlb-tcp-http"
    }
  )

  lifecycle {
    ignore_changes = [
      default_action,
    ]
  }
}

resource "aws_lb_listener" "nlb_prod" {
  count             = var.load_balancer_type == "nlb" ? 1 : 0
  port              = "443" # Standard HTTPS port
  protocol          = "TLS"
  load_balancer_arn = var.nlb_arn
  certificate_arn   = var.acm_certificate_arn

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.target_group_blue.arn
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-nlb-tls-prod"
    }
  )

  lifecycle {
    ignore_changes = [
      default_action,
    ]
  }
}

# NLB test listener on different port
resource "aws_lb_listener" "nlb_test" {
  count             = var.load_balancer_type == "nlb" ? 1 : 0
  port              = "10443" # Standard test port
  protocol          = "TLS"
  load_balancer_arn = var.nlb_arn
  certificate_arn   = var.acm_certificate_arn

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.target_group_green.arn
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-nlb-tcp-test"
    }
  )

  lifecycle {
    ignore_changes = [
      default_action,
    ]
  }
}

# ECS Security Group is created externally to avoid cycle dependencies with RDS/ElastiCache
# Pass the security group ID via var.ecs_security_group_id

# Add security group rule to allow ALB to access ECS
resource "aws_security_group_rule" "ecs_allow_alb" {
  type                     = "ingress"
  from_port                = var.container_port
  to_port                  = var.container_port
  protocol                 = "tcp"
  security_group_id        = var.ecs_security_group_id
  source_security_group_id = var.alb_security_group_id
  description              = "Allow inbound traffic from ALB to ECS tasks"
}

resource "aws_ecs_service" "ecs_service" {
  name                   = "${var.app_name}-server-service"
  launch_type            = "FARGATE"
  desired_count          = var.desired_task_count
  cluster                = var.cluster_name
  task_definition        = aws_ecs_task_definition.task_definition.arn
  enable_execute_command = true

  network_configuration {
    security_groups  = [var.ecs_security_group_id]
    subnets          = var.subnet_ids
    assign_public_ip = var.assign_public_ip
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.target_group_blue.arn
    container_name   = var.container_names[0]
    container_port   = var.container_port
  }

  deployment_controller {
    type = "CODE_DEPLOY"
  }

  # For NLB, ensure listeners are created before the service
  depends_on = [
    aws_lb_listener.nlb_prod,
    aws_lb_listener.nlb_test
  ]

  lifecycle {
    ignore_changes = [
      load_balancer,
      task_definition
    ]
  }
  tags = merge(
    var.tags,
    {
      Name = "${var.app_name}-server-service"
    }
  )
}
